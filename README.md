2    Description of the work2.1KnapsackIn  this  coursework,  we  want  to  write  a  classKnapsack.   Its  instances  can  store  andprovide information about objects of a classItemthat has already been written.  TheItems stored in ourKnapsackobjects are very simple:  they have a name and a weight.AKnapsackobject can then tell us, e.g., the average weight of its current items, thenumber of current items, . . .The following example:1
Knapsack sack = new Knapsack();sack.add(new Item("Soda", 400)) ;sack.add(new Item("Book", 100));System.out.println(sack.numberOfItems());sack.add(new Item("Pen", 15));System.out.println(sack.numberOfItems());should print:23Here, the methodnumberOfItems()returns the number of items that have been addedto  the  knapsack  so  far.   When  we  calledsack.numberOfItems()for  the  first  time,only  the  first  two  items,  named"Soda"and"Book",  had  been  added  to  our  knap-sack, so the result was2.  When we then calledsack.numberOfItems()for the sec-ond  time,  the  third  item,  named"Pen",  had  also  been  added  to  our  knapsack,  sothe  result  was3.   Thus,  the  same  method  call  on  the  same  knapsack  object  (e.g.,sack.numberOfItems()) can have different results, depending on the state of the ob-ject.In this coursework we do not want to analyse anynullitem references.  So,  thecode snippetKnapsack sack = new Knapsack();sack.add(new Item("Soda", 400));sack.add(null);System.out.println(sack.numberOfItems());should print:1It isup to youas the implementor of the classKnapsackwhether the methodaddor themethodnumberOfItemsdeals with thenullreferences that may occur as an argumentofadd.  For the users of your class (who only care about the “behaviour” of its objects,i.e., what effects calling the methods on the objects have), this is an implementationdetail that they need not know about.  What they (mainly) care about is that yourmethods always give the right results.Thepublic interfaceof the classKnapsackis already present in the repository in theform of headers for constructors and methods and documentation comments describingthe desired behaviour.  However, the current methodimplementationsare “stubs” thatallow the code to compile but not to work correctly.  Thus, you will need to provideimplementations for these methods that work correctly according to the documentationof the public interface of the classKnapsack.  You will certainly also need one (or more)suitableprivateinstance variables — also called fields or attributes — for the classKnapsack.2
2.2Coursework1MainWe are providing the fileCoursework1Main.javain the repository.  This class makesuse of some of the desired functionalities of the classKnapsackin themainmethod. Youcan(andshould)testyourimplementationofKnapsackbyrunningCoursework1Main.main.   These  tests  provide  further  clarification  for  the  behaviourthatKnapsackis  supposed  to  show.   It  is  a  requirement  that  your  implementationofKnapsackcompiles  and  works  with  theunmodifiedCoursework1Main.javaandItem.java.   You  should  expect  that  we  will  use  the  original  versions  of  these  filesto test your implementation of theKnapsackclass,  not the ones that you may havemodified!The fileCoursework1Main.javaalso contains a comment at the end with the outputthat itsmainmethod produces with our implementation of theKnapsackclass.Note,  however,  that  the  tests  performed  byCoursework1Mainare  not  meant  tobe exhaustive — so even ifCoursework1Mainhas the desired outputs, this does notautomatically mean that your implementation is necessarily correct for all purposes.Thus, it is a good idea to not only test your code with further test cases, but also toreview it before handing in your solution.

